# Термины из рецензии

## Cross-encoder reranking

**Что это:** Двухэтапный retrieval: сначала быстрый поиск (BM25 или bi-encoder) даёт топ-N кандидатов, затем **cross-encoder** переранжирует только эти N пар (query, passage) и возвращает финальный топ-k.

**Отличие от bi-encoder (dense):**
- **Bi-encoder:** query и passage кодируются отдельно, similarity = dot(embed_q, embed_p). Быстро, можно индексировать один раз.
- **Cross-encoder:** одна модель получает на вход пару (query, passage) и выдаёт один скор релевантности. Точнее, но O(N) вызовов на запрос — дорого для всего корпуса.

**Зачем в RAG:** Сильно поднимает точность retrieval (особенно MRR/NDCG), потому что модель явно видит пару вопрос–отрывок. Типичные модели: ms-marco, BGE reranker, Cohere rerank.

**В нашем пайплайне:** Сейчас не используется. Добавление = новый модуль (загрузка reranker, вызов после BM25/Vector/Hybrid, выбор top_k после rerank).

---

## Proper validation split

**Что это:** Разделение данных на три непересекающихся множества:
- **Train** — подбор гиперпараметров (например, RRF k, α).
- **Validation / Dev** — ранняя остановка, выбор лучшей конфигурации, проверка на переобучение.
- **Test** — финальная оценка **один раз**, без подглядывания.

**Проблема без него:** Если RRF-параметры (или любые другие) подбирались по тем же 100 вопросам, по которым потом считаются метрики, то метрики **завышены** (data leakage). Рецензент как раз это и указывает.

**Proper validation split в нашем случае означает:**
1. Иметь отдельный **dev set** (например, 20% вопросов) и на нём перебирать k, α для RRF.
2. Фиксировать лучшие k, α.
3. Финальные цифры (Recall@6, accuracy) считать только на **test set**, который не использовался ни для подбора, ни для ранней остановки.

**Сейчас:** Cross-validation по 5 фолдам есть, но если лучшие k/α выбирались по тем же фолдам, что и финальная оценка — это и есть «нет proper validation split». Исправление: один раз выделить dev (например, 1 фолд или отдельный файл dev_questions.json), на нём гонять grid search, на остальных — только финальный eval с зафиксированными k, α.
